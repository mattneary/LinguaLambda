<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <title>Translating Programs from Imperative to Functional Style</title>
        <meta name="viewport" content="width=device-width">

        <!-- syntax highlighting CSS -->
        <link rel="stylesheet" href="/css/syntax.css">

        <!-- Custom CSS -->
        <link rel="stylesheet" href="/css/main.css">

    </head>
    <body>

        <div class="container">
          <div class="site">
            <div class="header">
              <h1 class="title"><a href="/">Lingua Lambda</a></h1>
<!--              <a class="extra" href="/">home</a><br>          -->
              <em>traversing the tongues of computation</em>
            </div>

                <h2>Translating Programs from Imperative to Functional Style</h2>
<p class="meta">07 Aug 2013</p>

<div class="post">
<h2 id='the_two_styles'>The Two Styles</h2>

<p>There are two basic approaches to programming, derived from the two original theories of computation. The approach more familiar to most programmers is imperative; however, this is mostly due to the prevalence of certain languages and perhaps the less steep learning curve of the approach. Functional programming is just as robust, often more succinct, and almost always renders a more easily tested product.</p>

<h2 id='a_basic_example'>A Basic Example</h2>

<p>The following is a factorial function implemented in C. The result is achieved by defining a sequence of numbers over which to iterate, and then upon each step multiplying an accumulator by one of those numbers.</p>
<div class='highlight'><pre><code class='c'><span class='kt'>int</span> <span class='nf'>fact</span><span class='p'>(</span><span class='kt'>int</span> <span class='n'>num</span><span class='p'>)</span> <span class='p'>{</span>
	<span class='kt'>int</span> <span class='n'>ans</span> <span class='o'>=</span> <span class='mi'>1</span><span class='p'>;</span>
	<span class='k'>for</span><span class='p'>(</span> <span class='kt'>int</span> <span class='n'>i</span> <span class='o'>=</span> <span class='mi'>1</span><span class='p'>;</span> <span class='n'>i</span> <span class='o'>&lt;=</span> <span class='n'>num</span><span class='p'>;</span> <span class='n'>i</span><span class='o'>++</span> <span class='p'>)</span> <span class='p'>{</span>
		<span class='n'>ans</span> <span class='o'>*=</span> <span class='n'>i</span><span class='p'>;</span>
	<span class='p'>}</span>
	<span class='k'>return</span> <span class='n'>ans</span><span class='p'>;</span>
<span class='p'>}</span>
<span class='kt'>int</span> <span class='nf'>main</span><span class='p'>()</span> <span class='p'>{</span>
	<span class='n'>printf</span><span class='p'>(</span><span class='s'>&quot;5!: %d&quot;</span><span class='p'>,</span> <span class='n'>fact</span><span class='p'>(</span><span class='mi'>5</span><span class='p'>));</span>
<span class='p'>}</span>
</code></pre></div>
<p>The following solves the same problem, but this example is written in Haskell. Haskell is a functional language that accommodates our now recursive definition nicely. The following program is much like a mathematical definition of the factorial.</p>
<div class='highlight'><pre><code class='c'><span class='n'>fact</span> <span class='mi'>0</span> <span class='o'>=</span> <span class='mi'>1</span>
<span class='n'>fact</span> <span class='n'>n</span> <span class='o'>=</span> <span class='n'>n</span> <span class='o'>*</span> <span class='p'>(</span><span class='n'>fact</span> <span class='err'>$</span> <span class='n'>n</span> <span class='o'>-</span> <span class='mi'>1</span><span class='p'>)</span>
<span class='n'>main</span> <span class='o'>=</span> <span class='n'>putStrLn</span> <span class='err'>$</span> <span class='s'>&quot;5!: &quot;</span> <span class='o'>++</span> <span class='p'>(</span><span class='n'>show</span> <span class='err'>$</span> <span class='n'>fact</span> <span class='mi'>5</span><span class='p'>)</span>
</code></pre></div>
<p>The above closely resembles a Mathematic definition, which is very a much characteristic of functional programs. Their declarative definition results in communication not of a process of computation, but rather, a definition of a relation.</p>

<p>It should be noted that recursion is not limited to those few languages that are perfectly functional; rather, recursion, as well as all of the general principles of functional programming, may be utilized in your language of choice.</p>

<h2 id='translating_an_algorithm'>Translating an Algorithm</h2>

<p>Now we will jump right in to a non-trivial problem, stated below.</p>

<pre><code>Given a string of nested parenthesized groups, return a nested 
list containing the contents of these groups. For example, given 
the list of characters `a(bc)d` return `[a, [b, c], d]`.</code></pre>

<p>We will begin with an imperative approach. Thus think, what is the easily defined iterative process underlying this problem? The answer is clearly navigation of the string, and so we begin with a <code>for</code> loop that will cycle through each character of the string in order.</p>
<div class='highlight'><pre><code class='javascript'><span class='kd'>var</span> <span class='nx'>parse</span> <span class='o'>=</span> <span class='kd'>function</span><span class='p'>(</span><span class='nx'>expr</span><span class='p'>)</span> <span class='p'>{</span>
	<span class='k'>for</span><span class='p'>(</span> <span class='kd'>var</span> <span class='nx'>i</span> <span class='o'>=</span> <span class='mi'>0</span><span class='p'>;</span> <span class='nx'>i</span> <span class='o'>&lt;</span> <span class='nx'>expr</span><span class='p'>.</span><span class='nx'>length</span><span class='p'>;</span> <span class='nx'>i</span><span class='o'>++</span> <span class='p'>)</span> <span class='p'>{</span>
		<span class='kd'>var</span> <span class='nx'>read</span> <span class='o'>=</span> <span class='nx'>expr</span><span class='p'>[</span><span class='nx'>i</span><span class='p'>];</span>
		<span class='c1'>// ...</span>
	<span class='p'>}</span>
<span class='p'>}</span>
</code></pre></div>
<p>Now we will need to describe a slightly more specific strategy in performing the desired process.</p>

<ol>
<li>A parenthetical will be split from the string, with a segment, although possibly an empty one, before and after it.</li>

<li>Once a parenthetical has been removed, we will need to recurse on these segments, i.e., the parenthetical and the portion after it.</li>
</ol>

<p>To make our way toward this implementation, we will define a variable <code>before</code> that will hold the segment of the string occurring prior to any parenthetical; a variable <code>accum</code> that will hold characters that have been read in but whose destination has yet to be determined, in this way serving as a cache; <code>paren</code> which will hold a separated out parenthetical; and <code>found</code> which will be true if and only if a parenthetical has been parsed.</p>
<div class='highlight'><pre><code class='javascript'><span class='kd'>var</span> <span class='nx'>parse</span> <span class='o'>=</span> <span class='kd'>function</span><span class='p'>(</span><span class='nx'>expr</span><span class='p'>)</span> <span class='p'>{</span>
	<span class='kd'>var</span> <span class='nx'>before</span><span class='p'>,</span>
		<span class='nx'>accum</span> <span class='o'>=</span> <span class='p'>[],</span>
		<span class='nx'>paren</span><span class='p'>,</span>
		<span class='nx'>found</span> <span class='o'>=</span> <span class='kc'>false</span><span class='p'>;</span>		
	<span class='k'>for</span><span class='p'>(</span> <span class='kd'>var</span> <span class='nx'>i</span> <span class='o'>=</span> <span class='mi'>0</span><span class='p'>;</span> <span class='nx'>i</span> <span class='o'>&lt;</span> <span class='nx'>expr</span><span class='p'>.</span><span class='nx'>length</span><span class='p'>;</span> <span class='nx'>i</span><span class='o'>++</span> <span class='p'>)</span> <span class='p'>{</span>
		<span class='kd'>var</span> <span class='nx'>read</span> <span class='o'>=</span> <span class='nx'>expr</span><span class='p'>[</span><span class='nx'>i</span><span class='p'>];</span>
		<span class='c1'>// ...</span>
	<span class='p'>}</span>
<span class='p'>}</span>
</code></pre></div>
<p>In order to parse out the parenthetical, however, we will need an additional variable. This variable will aid us in parsing nested parentheses to separate out the top-level parenthetical.</p>

<p>We will need to handle three obvious classes of characters in our parsing of the parentheses:</p>

<ol>
<li>An opening parenthesis.</li>

<li>A closing parenthesis.</li>

<li>Any other character.</li>
</ol>

<p>Additionally, the class of a character may be disregarded if we have already parsed a top-level parenthetical. Its parsing will be handled when we are ready to recurse. Given these additions of case-handling, we insert <code>if ... else</code> statements as in the following.</p>
<div class='highlight'><pre><code class='javascript'><span class='kd'>var</span> <span class='nx'>parse</span> <span class='o'>=</span> <span class='kd'>function</span><span class='p'>(</span><span class='nx'>expr</span><span class='p'>)</span> <span class='p'>{</span>
	<span class='kd'>var</span> <span class='nx'>nested</span> <span class='o'>=</span> <span class='mi'>0</span><span class='p'>,</span>
		<span class='nx'>before</span><span class='p'>,</span>
		<span class='nx'>paren</span><span class='p'>,</span>
		<span class='nx'>accum</span> <span class='o'>=</span> <span class='p'>[],</span>
		<span class='nx'>found</span> <span class='o'>=</span> <span class='kc'>false</span><span class='p'>;</span>
	<span class='k'>for</span><span class='p'>(</span> <span class='kd'>var</span> <span class='nx'>i</span> <span class='o'>=</span> <span class='mi'>0</span><span class='p'>;</span> <span class='nx'>i</span> <span class='o'>&lt;</span> <span class='nx'>expr</span><span class='p'>.</span><span class='nx'>length</span><span class='p'>;</span> <span class='nx'>i</span><span class='o'>++</span> <span class='p'>)</span> <span class='p'>{</span>
		<span class='kd'>var</span> <span class='nx'>read</span> <span class='o'>=</span> <span class='nx'>expr</span><span class='p'>[</span><span class='nx'>i</span><span class='p'>];</span>
		<span class='k'>if</span><span class='p'>(</span> <span class='nx'>read</span> <span class='o'>==</span> <span class='s1'>&#39;(&#39;</span> <span class='o'>&amp;&amp;</span> <span class='o'>!</span><span class='nx'>found</span> <span class='p'>)</span> <span class='p'>{</span>
			<span class='c1'>// Class 1. An opening parenthesis.</span>
			<span class='c1'>// ...</span>
		<span class='p'>}</span> <span class='k'>else</span> <span class='k'>if</span><span class='p'>(</span> <span class='nx'>read</span> <span class='o'>==</span> <span class='s1'>&#39;)&#39;</span> <span class='o'>&amp;&amp;</span> <span class='o'>!</span><span class='nx'>found</span> <span class='p'>)</span> <span class='p'>{</span>
			<span class='c1'>// Class 2. A closing parenthesis.</span>
			<span class='c1'>// ...</span>
		<span class='p'>}</span> <span class='k'>else</span> <span class='p'>{</span>
			<span class='c1'>// Class 3. Any other character.</span>
			<span class='c1'>// ...</span>
		<span class='p'>}</span>
	<span class='p'>}</span>
<span class='p'>};</span>
</code></pre></div>
<p>Of course, we will need to combine any separated out parenthetical with the components occurring before and after it to form the designated response. Hence we provide the following <code>return</code> statement.</p>
<div class='highlight'><pre><code class='javascript'><span class='kd'>var</span> <span class='nx'>parse</span> <span class='o'>=</span> <span class='kd'>function</span><span class='p'>(</span><span class='nx'>expr</span><span class='p'>)</span> <span class='p'>{</span>
	<span class='c1'>// variables...</span>
	<span class='k'>for</span><span class='p'>(</span> <span class='kd'>var</span> <span class='nx'>i</span> <span class='o'>=</span> <span class='mi'>0</span><span class='p'>;</span> <span class='nx'>i</span> <span class='o'>&lt;</span> <span class='nx'>expr</span><span class='p'>.</span><span class='nx'>length</span><span class='p'>;</span> <span class='nx'>i</span><span class='o'>++</span> <span class='p'>)</span> <span class='p'>{</span>
		<span class='c1'>// parse...</span>
	<span class='p'>}</span>
	<span class='k'>if</span><span class='p'>(</span> <span class='nx'>paren</span> <span class='p'>)</span> <span class='p'>{</span>
		<span class='k'>return</span> <span class='nx'>before</span><span class='p'>.</span><span class='nx'>concat</span><span class='p'>([</span><span class='nx'>paren</span><span class='p'>]).</span><span class='nx'>concat</span><span class='p'>(</span><span class='nx'>parse</span><span class='p'>(</span><span class='nx'>accum</span><span class='p'>));</span>
	<span class='p'>}</span> <span class='k'>else</span> <span class='p'>{</span>
		<span class='k'>return</span> <span class='nx'>expr</span><span class='p'>;</span>
	<span class='p'>}</span>
<span class='p'>};</span>
</code></pre></div>
<p>Now we implement our nesting logic and the final algorithm. Nesting will be handled based on one of the following occurences.</p>

<ol>
<li>A once nested expression was just opened.</li>

<li>An expression was just closed to be un-nested.</li>

<li>Parentheses occurred within a nested expression.</li>
</ol>

<p>Cases <code>1.</code> and <code>2.</code> are handled under the conditionals for their respective character classes, and in either class under another nesting case case <code>3.</code> is handled.</p>

<p>The last components missing from our implementation are the building up of an accumulator and the setting of the various components to the accumulator. We will implement these portions in the following code.</p>

<ul>
<li>When the parenthetical is closed, it is recursively <code>parsed</code> and set to the <code>paren</code> variable.</li>

<li>When a parenthetical is open, <code>before</code> receives the accumulator value.</li>
</ul>
<div class='highlight'><pre><code class='javascript'><span class='kd'>var</span> <span class='nx'>parse</span> <span class='o'>=</span> <span class='kd'>function</span><span class='p'>(</span><span class='nx'>expr</span><span class='p'>)</span> <span class='p'>{</span>
	<span class='kd'>var</span> <span class='nx'>nested</span> <span class='o'>=</span> <span class='mi'>0</span><span class='p'>,</span>
		<span class='nx'>before</span><span class='p'>,</span>
		<span class='nx'>paren</span><span class='p'>,</span>
		<span class='nx'>accum</span> <span class='o'>=</span> <span class='p'>[],</span>
		<span class='nx'>found</span> <span class='o'>=</span> <span class='kc'>false</span><span class='p'>;</span>
	<span class='k'>for</span><span class='p'>(</span> <span class='kd'>var</span> <span class='nx'>i</span> <span class='o'>=</span> <span class='mi'>0</span><span class='p'>;</span> <span class='nx'>i</span> <span class='o'>&lt;</span> <span class='nx'>expr</span><span class='p'>.</span><span class='nx'>length</span><span class='p'>;</span> <span class='nx'>i</span><span class='o'>++</span> <span class='p'>)</span> <span class='p'>{</span>
		<span class='kd'>var</span> <span class='nx'>read</span> <span class='o'>=</span> <span class='nx'>expr</span><span class='p'>[</span><span class='nx'>i</span><span class='p'>];</span>
		<span class='k'>if</span><span class='p'>(</span> <span class='nx'>read</span> <span class='o'>==</span> <span class='s1'>&#39;(&#39;</span> <span class='o'>&amp;&amp;</span> <span class='o'>!</span><span class='nx'>found</span> <span class='p'>)</span> <span class='p'>{</span>
			<span class='nx'>nested</span><span class='o'>++</span><span class='p'>;</span>
			<span class='k'>if</span><span class='p'>(</span> <span class='nx'>nested</span> <span class='o'>==</span> <span class='mi'>1</span> <span class='p'>)</span> <span class='p'>{</span>
				<span class='nx'>before</span> <span class='o'>=</span> <span class='nx'>accum</span><span class='p'>;</span>
				<span class='nx'>accum</span> <span class='o'>=</span> <span class='p'>[];</span>
			<span class='p'>}</span> <span class='k'>else</span> <span class='p'>{</span>
				<span class='nx'>accum</span><span class='p'>.</span><span class='nx'>push</span><span class='p'>(</span><span class='nx'>read</span><span class='p'>);</span>
			<span class='p'>}</span>
		<span class='p'>}</span> <span class='k'>else</span> <span class='k'>if</span><span class='p'>(</span> <span class='nx'>read</span> <span class='o'>==</span> <span class='s1'>&#39;)&#39;</span> <span class='o'>&amp;&amp;</span> <span class='o'>!</span><span class='nx'>found</span> <span class='p'>)</span> <span class='p'>{</span>
			<span class='nx'>nested</span><span class='o'>--</span><span class='p'>;</span>
			<span class='k'>if</span><span class='p'>(</span> <span class='nx'>nested</span> <span class='o'>==</span> <span class='mi'>0</span> <span class='p'>)</span> <span class='p'>{</span>
				<span class='nx'>found</span> <span class='o'>=</span> <span class='kc'>true</span><span class='p'>;</span>
				<span class='nx'>paren</span> <span class='o'>=</span> <span class='nx'>parse</span><span class='p'>(</span><span class='nx'>accum</span><span class='p'>);</span>
				<span class='nx'>accum</span> <span class='o'>=</span> <span class='p'>[];</span>
			<span class='p'>}</span> <span class='k'>else</span> <span class='p'>{</span>
				<span class='nx'>accum</span><span class='p'>.</span><span class='nx'>push</span><span class='p'>(</span><span class='nx'>read</span><span class='p'>);</span>
			<span class='p'>}</span>
		<span class='p'>}</span> <span class='k'>else</span> <span class='p'>{</span>
			<span class='nx'>accum</span><span class='p'>.</span><span class='nx'>push</span><span class='p'>(</span><span class='nx'>read</span><span class='p'>);</span>
		<span class='p'>}</span>
	<span class='p'>}</span>
	<span class='k'>if</span><span class='p'>(</span> <span class='nx'>paren</span> <span class='p'>)</span> <span class='p'>{</span>
		<span class='k'>return</span> <span class='nx'>before</span><span class='p'>.</span><span class='nx'>concat</span><span class='p'>([</span><span class='nx'>paren</span><span class='p'>]).</span><span class='nx'>concat</span><span class='p'>(</span><span class='nx'>parse</span><span class='p'>(</span><span class='nx'>accum</span><span class='p'>));</span>
	<span class='p'>}</span> <span class='k'>else</span> <span class='p'>{</span>
		<span class='k'>return</span> <span class='nx'>expr</span><span class='p'>;</span>
	<span class='p'>}</span>		
<span class='p'>};</span>
</code></pre></div>
<p>From the above final implementation of our program we can derive a functional version. The differences will be based on the following principles of functional programming:</p>

<ol>
<li>Values shall not be mutated.</li>

<li>Control-flow shall not be explicit.</li>

<li>Recursion is dope.</li>
</ol>

<p>Let&#8217;s begin by abiding to rule <code>2</code>, inspired by principle number three. The first thing you will notice is that all variables were made function arguments. This is because in a pure function, the only state is provided by the arguments. Hence when recursing, we will need to pass all required data to the function as argument.</p>

<p>Also of note is the fact that rather than maintain an index of the list on which we are operating, we pass as argument to the recursive call only subsequent characters, i.e., those which have yet to be read. This is both logical in that our progress in navigating the list is maintained, and idiomatic in that Lisp, for example, provides a function for trailing values of a list, <code>cdr</code>, as well as a function to get the first element, <code>car</code>.</p>
<div class='highlight'><pre><code class='javascript'><span class='kd'>var</span> <span class='nx'>fparse</span> <span class='o'>=</span> <span class='kd'>function</span><span class='p'>(</span><span class='nx'>expr</span><span class='p'>,</span> <span class='nx'>nested</span><span class='p'>,</span> <span class='nx'>before</span><span class='p'>,</span> <span class='nx'>paren</span><span class='p'>,</span> <span class='nx'>accum</span><span class='p'>,</span> <span class='nx'>found</span><span class='p'>)</span> <span class='p'>{</span>
	<span class='k'>if</span><span class='p'>(</span> <span class='nx'>expr</span><span class='p'>.</span><span class='nx'>length</span> <span class='o'>==</span> <span class='mi'>0</span> <span class='p'>)</span> <span class='p'>{</span>
		<span class='k'>if</span><span class='p'>(</span> <span class='nx'>paren</span> <span class='p'>)</span> <span class='p'>{</span>
			<span class='k'>return</span> <span class='nx'>before</span><span class='p'>.</span><span class='nx'>concat</span><span class='p'>([</span><span class='nx'>paren</span><span class='p'>]).</span><span class='nx'>concat</span><span class='p'>(</span><span class='nx'>parse</span><span class='p'>(</span><span class='nx'>accum</span><span class='p'>));</span>
		<span class='p'>}</span> <span class='k'>else</span> <span class='p'>{</span>
			<span class='k'>return</span> <span class='nx'>expr</span><span class='p'>;</span>
		<span class='p'>}</span>
	<span class='p'>}</span> <span class='k'>else</span> <span class='p'>{</span>
		<span class='kd'>var</span> <span class='nx'>read</span> <span class='o'>=</span> <span class='nx'>expr</span><span class='p'>[</span><span class='mi'>0</span><span class='p'>];</span>
		<span class='k'>if</span><span class='p'>(</span> <span class='nx'>read</span> <span class='o'>==</span> <span class='s1'>&#39;(&#39;</span> <span class='o'>&amp;&amp;</span> <span class='o'>!</span><span class='nx'>found</span> <span class='p'>)</span> <span class='p'>{</span>
			<span class='nx'>nested</span><span class='o'>++</span><span class='p'>;</span>
			<span class='k'>if</span><span class='p'>(</span> <span class='nx'>nested</span> <span class='o'>==</span> <span class='mi'>1</span> <span class='p'>)</span> <span class='p'>{</span>
				<span class='nx'>before</span> <span class='o'>=</span> <span class='nx'>accum</span><span class='p'>;</span>
				<span class='nx'>accum</span> <span class='o'>=</span> <span class='p'>[];</span>
			<span class='p'>}</span> <span class='k'>else</span> <span class='p'>{</span>
				<span class='nx'>accum</span><span class='p'>.</span><span class='nx'>push</span><span class='p'>(</span><span class='nx'>read</span><span class='p'>);</span>
			<span class='p'>}</span>
		<span class='p'>}</span> <span class='k'>else</span> <span class='k'>if</span><span class='p'>(</span> <span class='nx'>read</span> <span class='o'>==</span> <span class='s1'>&#39;)&#39;</span> <span class='o'>&amp;&amp;</span> <span class='o'>!</span><span class='nx'>found</span> <span class='p'>)</span> <span class='p'>{</span>
			<span class='nx'>nested</span><span class='o'>--</span><span class='p'>;</span>
			<span class='k'>if</span><span class='p'>(</span> <span class='nx'>nested</span> <span class='o'>==</span> <span class='mi'>0</span> <span class='p'>)</span> <span class='p'>{</span>
				<span class='nx'>found</span> <span class='o'>=</span> <span class='kc'>true</span><span class='p'>;</span>
				<span class='nx'>paren</span> <span class='o'>=</span> <span class='nx'>parse</span><span class='p'>(</span><span class='nx'>accum</span><span class='p'>);</span>
				<span class='nx'>accum</span> <span class='o'>=</span> <span class='p'>[];</span>
			<span class='p'>}</span> <span class='k'>else</span> <span class='p'>{</span>
				<span class='nx'>accum</span><span class='p'>.</span><span class='nx'>push</span><span class='p'>(</span><span class='nx'>read</span><span class='p'>);</span>
			<span class='p'>}</span>
		<span class='p'>}</span> <span class='k'>else</span> <span class='p'>{</span>
			<span class='nx'>accum</span><span class='p'>.</span><span class='nx'>push</span><span class='p'>(</span><span class='nx'>read</span><span class='p'>);</span>
		<span class='p'>}</span>
		<span class='k'>return</span> <span class='nx'>fparse</span><span class='p'>(</span><span class='nx'>expr</span><span class='p'>.</span><span class='nx'>slice</span><span class='p'>(</span><span class='mi'>1</span><span class='p'>),</span> <span class='nx'>nested</span><span class='p'>,</span> <span class='nx'>before</span><span class='p'>,</span> <span class='nx'>paren</span><span class='p'>,</span> <span class='nx'>accum</span><span class='p'>,</span> <span class='nx'>found</span><span class='p'>);</span>
	<span class='p'>}</span>
<span class='p'>};</span>
<span class='kd'>var</span> <span class='nx'>fparse_</span> <span class='o'>=</span> <span class='kd'>function</span><span class='p'>(</span><span class='nx'>expr</span><span class='p'>)</span> <span class='p'>{</span>
	<span class='k'>return</span> <span class='nx'>fparse</span><span class='p'>(</span><span class='nx'>expr</span><span class='p'>,</span> <span class='mi'>0</span><span class='p'>,</span> <span class='nx'>nil</span><span class='p'>,</span> <span class='nx'>nil</span><span class='p'>,</span> <span class='nx'>nil</span><span class='p'>,</span> <span class='kc'>false</span><span class='p'>);</span>
<span class='p'>};</span>
</code></pre></div>
<p>The final portion of our program includes a definition of <code>fparse_</code>. This was merely for convenience, as <code>fparse_</code> provides all of the initialization values as argument to <code>fparse</code>.</p>

<p>We now remove mutation to achieve implementation of the final principle we listed. Our means of achieving this is by allowing all values to be function arguments or expressions operating on arguments.</p>
<div class='highlight'><pre><code class='javascript'><span class='kd'>var</span> <span class='nx'>fparse</span> <span class='o'>=</span> <span class='kd'>function</span><span class='p'>(</span><span class='nx'>expr</span><span class='p'>,</span> <span class='nx'>nested</span><span class='p'>,</span> <span class='nx'>before</span><span class='p'>,</span> <span class='nx'>paren</span><span class='p'>,</span> <span class='nx'>accum</span><span class='p'>,</span> <span class='nx'>found</span><span class='p'>)</span> <span class='p'>{</span>
	<span class='k'>if</span><span class='p'>(</span> <span class='nx'>expr</span><span class='p'>.</span><span class='nx'>length</span> <span class='o'>==</span> <span class='mi'>0</span> <span class='p'>)</span> <span class='p'>{</span>
		<span class='k'>if</span><span class='p'>(</span> <span class='nx'>paren</span> <span class='p'>)</span> <span class='p'>{</span>
			<span class='k'>return</span> <span class='nx'>before</span><span class='p'>.</span><span class='nx'>concat</span><span class='p'>([</span><span class='nx'>paren</span><span class='p'>]).</span><span class='nx'>concat</span><span class='p'>(</span><span class='nx'>parse</span><span class='p'>(</span><span class='nx'>accum</span><span class='p'>));</span>
		<span class='p'>}</span> <span class='k'>else</span> <span class='p'>{</span>
			<span class='k'>return</span> <span class='nx'>expr</span><span class='p'>;</span>
		<span class='p'>}</span>
	<span class='p'>}</span> <span class='k'>else</span> <span class='p'>{</span>
		<span class='k'>if</span><span class='p'>(</span> <span class='nx'>expr</span><span class='p'>[</span><span class='mi'>0</span><span class='p'>]</span> <span class='o'>==</span> <span class='s1'>&#39;(&#39;</span> <span class='o'>&amp;&amp;</span> <span class='o'>!</span><span class='nx'>found</span> <span class='p'>)</span> <span class='p'>{</span>
			<span class='k'>if</span><span class='p'>(</span> <span class='nx'>nested</span> <span class='o'>==</span> <span class='mi'>0</span> <span class='p'>)</span> <span class='p'>{</span>
				<span class='k'>return</span> <span class='nx'>fparse</span><span class='p'>(</span>
				  <span class='nx'>expr</span><span class='p'>.</span><span class='nx'>slice</span><span class='p'>(</span><span class='mi'>1</span><span class='p'>),</span> 
				  <span class='nx'>nested</span><span class='o'>+</span><span class='mi'>1</span><span class='p'>,</span> <span class='nx'>accum</span><span class='p'>,</span> 
				  <span class='nx'>paren</span><span class='p'>,</span> <span class='p'>[],</span> <span class='nx'>found</span><span class='p'>);</span>
			<span class='p'>}</span> <span class='k'>else</span> <span class='p'>{</span>
				<span class='k'>return</span> <span class='nx'>fparse</span><span class='p'>(</span>
				  <span class='nx'>expr</span><span class='p'>.</span><span class='nx'>slice</span><span class='p'>(</span><span class='mi'>1</span><span class='p'>),</span> 
				  <span class='nx'>nested</span><span class='o'>+</span><span class='mi'>1</span><span class='p'>,</span> 
				  <span class='nx'>before</span><span class='p'>,</span> <span class='nx'>paren</span><span class='p'>,</span> 
				  <span class='nx'>accum</span><span class='p'>.</span><span class='nx'>concat</span><span class='p'>(</span><span class='nx'>expr</span><span class='p'>[</span><span class='mi'>0</span><span class='p'>]),</span> <span class='nx'>found</span><span class='p'>);</span>
			<span class='p'>}</span>
		<span class='p'>}</span> <span class='k'>else</span> <span class='k'>if</span><span class='p'>(</span> <span class='nx'>expr</span><span class='p'>[</span><span class='mi'>0</span><span class='p'>]</span> <span class='o'>==</span> <span class='s1'>&#39;)&#39;</span> <span class='o'>&amp;&amp;</span> <span class='o'>!</span><span class='nx'>found</span> <span class='p'>)</span> <span class='p'>{</span>
			<span class='k'>if</span><span class='p'>(</span> <span class='nx'>nested</span> <span class='o'>==</span> <span class='mi'>1</span> <span class='p'>)</span> <span class='p'>{</span>
				<span class='k'>return</span> <span class='nx'>fparse</span><span class='p'>(</span>
				  <span class='nx'>expr</span><span class='p'>.</span><span class='nx'>slice</span><span class='p'>(</span><span class='mi'>1</span><span class='p'>),</span> 
				  <span class='nx'>nested</span><span class='o'>-</span><span class='mi'>1</span><span class='p'>,</span> 
				  <span class='nx'>before</span><span class='p'>,</span> <span class='nx'>parse</span><span class='p'>(</span><span class='nx'>accum</span><span class='p'>),</span> 
				  <span class='p'>[],</span> <span class='kc'>true</span><span class='p'>);</span>
			<span class='p'>}</span> <span class='k'>else</span> <span class='p'>{</span>
				<span class='k'>return</span> <span class='nx'>fparse</span><span class='p'>(</span>
				  <span class='nx'>expr</span><span class='p'>.</span><span class='nx'>slice</span><span class='p'>(</span><span class='mi'>1</span><span class='p'>),</span> 
				  <span class='nx'>nested</span><span class='o'>-</span><span class='mi'>1</span><span class='p'>,</span> 
				  <span class='nx'>before</span><span class='p'>,</span> <span class='nx'>paren</span><span class='p'>,</span> 
				  <span class='nx'>accum</span><span class='p'>.</span><span class='nx'>concat</span><span class='p'>(</span><span class='nx'>expr</span><span class='p'>[</span><span class='mi'>0</span><span class='p'>]),</span> <span class='nx'>found</span><span class='p'>);</span>
			<span class='p'>}</span>
		<span class='p'>}</span> <span class='k'>else</span> <span class='p'>{</span>
			<span class='k'>return</span> <span class='nx'>fparse</span><span class='p'>(</span>
			  <span class='nx'>expr</span><span class='p'>.</span><span class='nx'>slice</span><span class='p'>(</span><span class='mi'>1</span><span class='p'>),</span> 
			  <span class='nx'>nested</span><span class='p'>,</span> 
			  <span class='nx'>before</span><span class='p'>,</span> <span class='nx'>paren</span><span class='p'>,</span> 
			  <span class='nx'>accum</span><span class='p'>.</span><span class='nx'>concat</span><span class='p'>(</span><span class='nx'>expr</span><span class='p'>[</span><span class='mi'>0</span><span class='p'>]),</span> <span class='nx'>found</span><span class='p'>);</span>
		<span class='p'>}</span>		
	<span class='p'>}</span>
<span class='p'>};</span>
<span class='kd'>var</span> <span class='nx'>fparse_</span> <span class='o'>=</span> <span class='kd'>function</span><span class='p'>(</span><span class='nx'>expr</span><span class='p'>)</span> <span class='p'>{</span>
	<span class='k'>return</span> <span class='nx'>fparse</span><span class='p'>(</span><span class='nx'>expr</span><span class='p'>,</span> <span class='mi'>0</span><span class='p'>,</span> <span class='nx'>nil</span><span class='p'>,</span> <span class='nx'>nil</span><span class='p'>,</span> <span class='nx'>nil</span><span class='p'>,</span> <span class='kc'>false</span><span class='p'>);</span>
<span class='p'>};</span>
</code></pre></div>
<p>You should begin to see how our rewrite of this algorithm reads much more as an inductive definition than as a description of a process. In the following section we will make this even more evident.</p>

<h2 id='approaching_a_functional_language'>Approaching a Functional Language</h2>

<p>We have successfully implemented our algorithm while following the principles of functional programming. Now let&#8217;s consider definitions which will enable us to separate ourselves from the Object-Oriented foundation of our current language of operation. A few of these will have the potential to serve as <em>the</em> primitive functions of a functional language; however, we will not bother to take the route of derivation from first elements in this post.</p>

<p>We begin by defining functions for nearly all of the operations we performed above.</p>
<div class='highlight'><pre><code class='javascript'><span class='kd'>var</span> <span class='nx'>nil</span> <span class='o'>=</span> <span class='p'>[];</span>
<span class='kd'>var</span> <span class='nx'>isNull</span> <span class='o'>=</span> <span class='kd'>function</span><span class='p'>(</span><span class='nx'>x</span><span class='p'>)</span> <span class='p'>{</span> <span class='k'>return</span> <span class='nx'>x</span><span class='p'>.</span><span class='nx'>length</span> <span class='o'>==</span> <span class='mi'>0</span><span class='p'>;</span> <span class='p'>};</span>
<span class='kd'>var</span> <span class='nx'>push</span> <span class='o'>=</span> <span class='kd'>function</span><span class='p'>(</span><span class='nx'>a</span><span class='p'>,</span> <span class='nx'>b</span><span class='p'>)</span> <span class='p'>{</span> <span class='k'>return</span> <span class='nx'>a</span><span class='p'>.</span><span class='nx'>concat</span><span class='p'>([</span><span class='nx'>b</span><span class='p'>]);</span> <span class='p'>};</span>
<span class='kd'>var</span> <span class='nx'>concat</span> <span class='o'>=</span> <span class='kd'>function</span><span class='p'>(</span><span class='nx'>a</span><span class='p'>,</span> <span class='nx'>b</span><span class='p'>)</span> <span class='p'>{</span> <span class='k'>return</span> <span class='nx'>a</span><span class='p'>.</span><span class='nx'>concat</span><span class='p'>(</span><span class='nx'>b</span><span class='p'>);</span> <span class='p'>};</span>
<span class='kd'>var</span> <span class='nx'>car</span> <span class='o'>=</span> <span class='kd'>function</span><span class='p'>(</span><span class='nx'>x</span><span class='p'>)</span> <span class='p'>{</span> <span class='k'>return</span> <span class='nx'>x</span><span class='p'>[</span><span class='mi'>0</span><span class='p'>];</span> <span class='p'>};</span>
<span class='kd'>var</span> <span class='nx'>cdr</span> <span class='o'>=</span> <span class='kd'>function</span><span class='p'>(</span><span class='nx'>x</span><span class='p'>)</span> <span class='p'>{</span> <span class='k'>return</span> <span class='nx'>x</span><span class='p'>.</span><span class='nx'>slice</span><span class='p'>(</span><span class='mi'>1</span><span class='p'>);</span> <span class='p'>};</span>
<span class='kd'>var</span> <span class='nx'>add</span> <span class='o'>=</span> <span class='kd'>function</span><span class='p'>(</span><span class='nx'>a</span><span class='p'>,</span> <span class='nx'>b</span><span class='p'>)</span> <span class='p'>{</span> <span class='k'>return</span> <span class='nx'>a</span><span class='o'>+</span><span class='nx'>b</span><span class='p'>;</span> <span class='p'>};</span>
<span class='kd'>var</span> <span class='nx'>sub</span> <span class='o'>=</span> <span class='kd'>function</span><span class='p'>(</span><span class='nx'>a</span><span class='p'>,</span> <span class='nx'>b</span><span class='p'>)</span> <span class='p'>{</span> <span class='k'>return</span> <span class='nx'>a</span><span class='o'>-</span><span class='nx'>b</span><span class='p'>;</span> <span class='p'>};</span>
<span class='kd'>var</span> <span class='nx'>eq</span> <span class='o'>=</span> <span class='kd'>function</span><span class='p'>(</span><span class='nx'>a</span><span class='p'>,</span> <span class='nx'>b</span><span class='p'>)</span> <span class='p'>{</span> <span class='k'>return</span> <span class='nx'>a</span><span class='o'>==</span><span class='nx'>b</span><span class='p'>;</span> <span class='p'>};</span>
<span class='kd'>var</span> <span class='nx'>and</span> <span class='o'>=</span> <span class='kd'>function</span><span class='p'>(</span><span class='nx'>a</span><span class='p'>,</span> <span class='nx'>b</span><span class='p'>)</span> <span class='p'>{</span> <span class='k'>return</span> <span class='nx'>a</span> <span class='o'>&amp;&amp;</span> <span class='nx'>b</span><span class='p'>;</span> <span class='p'>};</span>
<span class='kd'>var</span> <span class='nx'>not</span> <span class='o'>=</span> <span class='kd'>function</span><span class='p'>(</span><span class='nx'>a</span><span class='p'>)</span> <span class='p'>{</span> <span class='k'>return</span> <span class='o'>!</span><span class='nx'>a</span><span class='p'>;</span> <span class='p'>};</span>
</code></pre></div>
<p>Now we incorporate these functions into our previous program.</p>
<div class='highlight'><pre><code class='javascript'><span class='kd'>var</span> <span class='nx'>fparse</span> <span class='o'>=</span> <span class='kd'>function</span><span class='p'>(</span><span class='nx'>expr</span><span class='p'>,</span> <span class='nx'>nested</span><span class='p'>,</span> <span class='nx'>before</span><span class='p'>,</span> <span class='nx'>paren</span><span class='p'>,</span> <span class='nx'>accum</span><span class='p'>,</span> <span class='nx'>found</span><span class='p'>)</span> <span class='p'>{</span>
	<span class='k'>if</span><span class='p'>(</span> <span class='nx'>isNull</span><span class='p'>(</span><span class='nx'>expr</span><span class='p'>)</span> <span class='p'>)</span>
		<span class='k'>if</span><span class='p'>(</span> <span class='nx'>not</span><span class='p'>(</span><span class='nx'>isNull</span><span class='p'>(</span><span class='nx'>paren</span><span class='p'>))</span> <span class='p'>)</span>
			<span class='k'>return</span> <span class='nx'>concat</span><span class='p'>(</span><span class='nx'>push</span><span class='p'>(</span><span class='nx'>before</span><span class='p'>,</span> <span class='nx'>paren</span><span class='p'>),</span> <span class='nx'>fparse_</span><span class='p'>(</span><span class='nx'>accum</span><span class='p'>));</span>
			<span class='k'>else</span> <span class='k'>return</span> <span class='nx'>accum</span><span class='p'>;</span>
	<span class='k'>else</span>
		<span class='k'>if</span><span class='p'>(</span> <span class='nx'>and</span><span class='p'>(</span><span class='nx'>eq</span><span class='p'>(</span><span class='nx'>car</span><span class='p'>(</span><span class='nx'>expr</span><span class='p'>),</span> <span class='s1'>&#39;(&#39;</span><span class='p'>),</span> <span class='nx'>not</span><span class='p'>(</span><span class='nx'>found</span><span class='p'>))</span> <span class='p'>)</span>
			<span class='k'>if</span><span class='p'>(</span> <span class='nx'>eq</span><span class='p'>(</span><span class='nx'>nested</span><span class='p'>,</span> <span class='mi'>0</span><span class='p'>)</span> <span class='p'>)</span>
				<span class='k'>return</span> <span class='nx'>fparse</span><span class='p'>(</span>
				  <span class='nx'>cdr</span><span class='p'>(</span><span class='nx'>expr</span><span class='p'>),</span> 
				  <span class='nx'>add</span><span class='p'>(</span><span class='nx'>nested</span><span class='p'>,</span> <span class='mi'>1</span><span class='p'>),</span> 
				  <span class='nx'>accum</span><span class='p'>,</span> <span class='nx'>paren</span><span class='p'>,</span> 
				  <span class='nx'>nil</span><span class='p'>,</span> <span class='nx'>found</span><span class='p'>);</span>
				<span class='k'>else</span> <span class='k'>return</span> <span class='nx'>fparse</span><span class='p'>(</span>
				  <span class='nx'>cdr</span><span class='p'>(</span><span class='nx'>expr</span><span class='p'>),</span> 
				  <span class='nx'>add</span><span class='p'>(</span><span class='nx'>nested</span><span class='p'>,</span> <span class='mi'>1</span><span class='p'>),</span> 
				  <span class='nx'>before</span><span class='p'>,</span> <span class='nx'>paren</span><span class='p'>,</span> 
				  <span class='nx'>push</span><span class='p'>(</span><span class='nx'>accum</span><span class='p'>,</span> <span class='nx'>car</span><span class='p'>(</span><span class='nx'>expr</span><span class='p'>)),</span> <span class='nx'>found</span><span class='p'>);</span>
		<span class='k'>else</span> <span class='k'>if</span><span class='p'>(</span> <span class='nx'>and</span><span class='p'>(</span><span class='nx'>eq</span><span class='p'>(</span><span class='nx'>car</span><span class='p'>(</span><span class='nx'>expr</span><span class='p'>),</span> <span class='s1'>&#39;)&#39;</span><span class='p'>),</span> <span class='nx'>not</span><span class='p'>(</span><span class='nx'>found</span><span class='p'>))</span> <span class='p'>)</span>
			<span class='k'>if</span><span class='p'>(</span> <span class='nx'>eq</span><span class='p'>(</span><span class='nx'>nested</span><span class='p'>,</span> <span class='mi'>1</span><span class='p'>)</span> <span class='p'>)</span>
				<span class='k'>return</span> <span class='nx'>fparse</span><span class='p'>(</span>
				  <span class='nx'>cdr</span><span class='p'>(</span><span class='nx'>expr</span><span class='p'>),</span> 
				  <span class='nx'>sub</span><span class='p'>(</span><span class='nx'>nested</span><span class='p'>,</span> <span class='mi'>1</span><span class='p'>),</span> 
				  <span class='nx'>before</span><span class='p'>,</span> <span class='nx'>fparse_</span><span class='p'>(</span><span class='nx'>accum</span><span class='p'>),</span> 
				  <span class='nx'>nil</span><span class='p'>,</span> <span class='kc'>true</span><span class='p'>);</span>
				<span class='k'>else</span> <span class='k'>return</span> <span class='nx'>fparse</span><span class='p'>(</span>
				  <span class='nx'>cdr</span><span class='p'>(</span><span class='nx'>expr</span><span class='p'>),</span> <span class='nx'>sub</span><span class='p'>(</span><span class='nx'>nested</span><span class='p'>,</span> <span class='mi'>1</span><span class='p'>),</span> 
				  <span class='nx'>before</span><span class='p'>,</span> <span class='nx'>paren</span><span class='p'>,</span> 
				  <span class='nx'>push</span><span class='p'>(</span><span class='nx'>accum</span><span class='p'>,</span> <span class='nx'>car</span><span class='p'>(</span><span class='nx'>expr</span><span class='p'>)),</span> <span class='nx'>found</span><span class='p'>);</span>
		<span class='k'>else</span>
			<span class='k'>return</span> <span class='nx'>fparse</span><span class='p'>(</span>
			  <span class='nx'>cdr</span><span class='p'>(</span><span class='nx'>expr</span><span class='p'>),</span> <span class='nx'>nested</span><span class='p'>,</span> 
			  <span class='nx'>before</span><span class='p'>,</span> <span class='nx'>paren</span><span class='p'>,</span> 
			  <span class='nx'>push</span><span class='p'>(</span><span class='nx'>accum</span><span class='p'>,</span> <span class='nx'>car</span><span class='p'>(</span><span class='nx'>expr</span><span class='p'>)),</span> <span class='nx'>found</span><span class='p'>);</span>		
<span class='p'>};</span>
<span class='kd'>var</span> <span class='nx'>fparse_</span> <span class='o'>=</span> <span class='kd'>function</span><span class='p'>(</span><span class='nx'>expr</span><span class='p'>)</span> <span class='p'>{</span>
	<span class='k'>return</span> <span class='nx'>fparse</span><span class='p'>(</span><span class='nx'>expr</span><span class='p'>,</span> <span class='mi'>0</span><span class='p'>,</span> <span class='nx'>nil</span><span class='p'>,</span> <span class='nx'>nil</span><span class='p'>,</span> <span class='nx'>nil</span><span class='p'>,</span> <span class='kc'>false</span><span class='p'>);</span>
<span class='p'>};</span>
</code></pre></div>
<p>The above is more readable to those familiar with the naming scheme of the functions, and more importantly, more homoiconic. We have removed the remnants of an Object-Oriented Language to leave only function application, <code>return</code> statements, and conditionals.</p>

<h2 id='writing_in_functional_languages'>Writing in Functional Languages</h2>

<p>The prior definitions of a prelude of functions was intentionally very much like Lisp or Scheme. We will now translate the code into Scheme, and you will see that it is nearly identical to our prior JavaScript.</p>
<div class='highlight'><pre><code class='scheme'><span class='p'>(</span><span class='k'>define </span><span class='p'>(</span><span class='nf'>fparse</span> <span class='nv'>expr</span> <span class='nv'>nested</span> <span class='nv'>before</span> <span class='nv'>paren</span> <span class='nv'>accum</span> <span class='nv'>found</span><span class='p'>)</span>
  <span class='p'>(</span><span class='nf'>if</span>
    <span class='p'>(</span><span class='nb'>null? </span><span class='nv'>expr</span><span class='p'>)</span>
    <span class='p'>(</span><span class='nf'>if</span>
      <span class='p'>(</span><span class='nb'>not </span><span class='p'>(</span><span class='nb'>null? </span><span class='nv'>paren</span><span class='p'>))</span>
      <span class='p'>(</span><span class='nf'>concat</span> <span class='p'>(</span><span class='nf'>push</span> <span class='nv'>before</span> <span class='nv'>paren</span><span class='p'>)</span> <span class='p'>(</span><span class='nf'>fparse_</span> <span class='nv'>accum</span><span class='p'>))</span>
      <span class='nv'>accum</span><span class='p'>)</span>
    <span class='p'>(</span><span class='k'>cond </span><span class='p'>(((</span><span class='k'>and </span><span class='p'>(</span><span class='nb'>eqv? </span><span class='p'>(</span><span class='nb'>car </span><span class='nv'>expr</span><span class='p'>)</span> <span class='ss'>&#39;po</span><span class='p'>)</span> <span class='p'>(</span><span class='nb'>not </span><span class='nv'>found</span><span class='p'>))</span>
            <span class='p'>(</span><span class='nf'>if</span>
             <span class='p'>(</span><span class='nb'>eqv? </span><span class='nv'>nested</span> <span class='mi'>0</span><span class='p'>)</span>
             <span class='p'>(</span><span class='nf'>fparse</span> <span class='p'>(</span><span class='nb'>cdr </span><span class='nv'>expr</span><span class='p'>)</span> <span class='p'>(</span><span class='nb'>+ </span><span class='nv'>nested</span> <span class='mi'>1</span><span class='p'>)</span> <span class='nv'>accum</span> <span class='nv'>paren</span> <span class='o'>&#39;</span><span class='p'>()</span> <span class='nv'>found</span><span class='p'>)</span>
             <span class='p'>(</span><span class='nf'>fparse</span> <span class='p'>(</span><span class='nb'>cdr </span><span class='nv'>expr</span><span class='p'>)</span> <span class='p'>(</span><span class='nb'>+ </span><span class='nv'>nested</span> <span class='mi'>1</span><span class='p'>)</span> <span class='nv'>before</span> <span class='nv'>paren</span> <span class='p'>(</span><span class='nf'>push</span> <span class='nv'>accum</span> <span class='p'>(</span><span class='nb'>car </span><span class='nv'>expr</span><span class='p'>))</span> <span class='nv'>found</span><span class='p'>)))</span> 
           <span class='p'>((</span><span class='k'>and </span><span class='p'>(</span><span class='nb'>eqv? </span><span class='p'>(</span><span class='nb'>car </span><span class='nv'>expr</span><span class='p'>)</span> <span class='ss'>&#39;pc</span><span class='p'>)</span> <span class='p'>(</span><span class='nb'>not </span><span class='nv'>found</span><span class='p'>))</span>
            <span class='p'>(</span><span class='nf'>if</span>
             <span class='p'>(</span><span class='nb'>eqv? </span><span class='nv'>nested</span> <span class='mi'>1</span><span class='p'>)</span>
             <span class='p'>(</span><span class='nf'>fparse</span> <span class='p'>(</span><span class='nb'>cdr </span><span class='nv'>expr</span><span class='p'>)</span> <span class='p'>(</span><span class='nb'>- </span><span class='nv'>nested</span> <span class='mi'>1</span><span class='p'>)</span> <span class='nv'>before</span> <span class='p'>(</span><span class='nf'>fparse_</span> <span class='nv'>accum</span><span class='p'>)</span> <span class='o'>&#39;</span><span class='p'>()</span> <span class='no'>#t</span><span class='p'>)</span>
             <span class='p'>(</span><span class='nf'>fparse</span> <span class='p'>(</span><span class='nb'>cdr </span><span class='nv'>expr</span><span class='p'>)</span> <span class='p'>(</span><span class='nb'>- </span><span class='nv'>nested</span> <span class='mi'>1</span><span class='p'>)</span> <span class='nv'>before</span> <span class='nv'>paren</span> <span class='p'>(</span><span class='nf'>push</span> <span class='nv'>accum</span> <span class='p'>(</span><span class='nb'>car </span><span class='nv'>expr</span><span class='p'>))</span> <span class='nv'>found</span><span class='p'>)))</span>
           <span class='p'>(</span><span class='no'>#t</span> <span class='p'>(</span><span class='nf'>fparse</span> <span class='p'>(</span><span class='nb'>cdr </span><span class='nv'>expr</span><span class='p'>)</span> <span class='nv'>nested</span> <span class='nv'>before</span> <span class='nv'>paren</span> <span class='p'>(</span><span class='nf'>push</span> <span class='nv'>accum</span> <span class='p'>(</span><span class='nb'>car </span><span class='nv'>expr</span><span class='p'>))</span> <span class='nv'>found</span><span class='p'>))))))</span>
<span class='p'>(</span><span class='k'>define </span><span class='p'>(</span><span class='nf'>fparse_</span> <span class='nv'>expr</span><span class='p'>)</span>
  <span class='p'>(</span><span class='nf'>fparse</span> <span class='nv'>expr</span> <span class='mi'>0</span> <span class='o'>&#39;</span><span class='p'>()</span> <span class='o'>&#39;</span><span class='p'>()</span> <span class='o'>&#39;</span><span class='p'>()</span> <span class='no'>#f</span><span class='p'>))</span>
</code></pre></div>
<p>Finally, we translate into Haskell! Haskell is a purely functional language with super-powerful pattern matching.</p>
<div class='highlight'><pre><code class='haskell'><span class='nf'>fparse</span> <span class='kt'>[]</span> <span class='n'>n</span> <span class='n'>before</span> <span class='kt'>[]</span> <span class='n'>accum</span> <span class='n'>found</span> <span class='ow'>=</span> <span class='n'>accum</span>
<span class='nf'>fparse</span> <span class='kt'>[]</span> <span class='n'>n</span> <span class='n'>before</span> <span class='n'>paren</span> <span class='n'>accum</span> <span class='n'>found</span> <span class='ow'>=</span> 
  <span class='p'>(</span><span class='n'>push</span> <span class='n'>before</span> <span class='n'>paren</span><span class='p'>)</span> <span class='o'>++</span> <span class='p'>(</span><span class='n'>fparse_</span> <span class='n'>accum</span><span class='p'>)</span>
<span class='nf'>fparse</span> <span class='p'>(</span><span class='sc'>&#39;(&#39;</span><span class='kt'>:</span><span class='n'>rest</span><span class='p'>)</span> <span class='mi'>0</span> <span class='n'>before</span> <span class='n'>paren</span> <span class='n'>accum</span> <span class='n'>found</span> <span class='ow'>=</span> 
  <span class='n'>fparse</span> <span class='p'>(</span><span class='n'>head</span> <span class='n'>expr</span><span class='p'>)</span> <span class='mi'>1</span> <span class='n'>accum</span> <span class='n'>paren</span> <span class='kt'>[]</span> <span class='n'>found</span>
<span class='nf'>fparse</span> <span class='p'>(</span><span class='sc'>&#39;(&#39;</span><span class='kt'>:</span><span class='n'>rest</span><span class='p'>)</span> <span class='n'>n</span> <span class='n'>before</span> <span class='n'>paren</span> <span class='n'>accum</span> <span class='n'>found</span> <span class='ow'>=</span> 
  <span class='n'>fparse</span> <span class='p'>(</span><span class='n'>head</span> <span class='n'>expr</span><span class='p'>)</span> <span class='p'>(</span><span class='n'>nested</span> <span class='o'>+</span> <span class='mi'>1</span><span class='p'>)</span> <span class='n'>before</span> <span class='n'>paren</span> <span class='p'>(</span><span class='n'>push</span> <span class='n'>accum</span> <span class='sc'>&#39;(&#39;</span><span class='p'>)</span> <span class='n'>found</span>
<span class='nf'>fparse</span> <span class='p'>(</span><span class='sc'>&#39;)&#39;</span><span class='kt'>:</span><span class='n'>rest</span><span class='p'>)</span> <span class='mi'>1</span> <span class='n'>before</span> <span class='n'>paren</span> <span class='n'>accum</span> <span class='n'>found</span> <span class='ow'>=</span> 
  <span class='n'>fparse</span> <span class='p'>(</span><span class='n'>tail</span> <span class='n'>expr</span><span class='p'>)</span> <span class='p'>(</span><span class='n'>nested</span> <span class='o'>-</span> <span class='mi'>1</span><span class='p'>)</span> <span class='n'>before</span> <span class='p'>(</span><span class='n'>fparse_</span> <span class='n'>accum</span><span class='p'>)</span> <span class='p'>(</span><span class='n'>push</span> <span class='n'>accum</span> <span class='sc'>&#39;)&#39;</span><span class='p'>)</span> <span class='n'>found</span>
<span class='nf'>fparse</span> <span class='p'>(</span><span class='sc'>&#39;)&#39;</span><span class='kt'>:</span><span class='n'>rest</span><span class='p'>)</span> <span class='n'>n</span> <span class='n'>before</span> <span class='n'>paren</span> <span class='n'>accum</span> <span class='n'>found</span> <span class='ow'>=</span> 
  <span class='n'>fparse</span> <span class='p'>(</span><span class='n'>tail</span> <span class='n'>expr</span><span class='p'>)</span> <span class='p'>(</span><span class='n'>nested</span> <span class='o'>-</span> <span class='mi'>1</span><span class='p'>)</span> <span class='n'>before</span> <span class='n'>paren</span> <span class='p'>(</span><span class='n'>push</span> <span class='n'>accum</span> <span class='sc'>&#39;)&#39;</span><span class='p'>)</span> <span class='n'>found</span>

<span class='nf'>fparse_</span> <span class='n'>expr</span> <span class='ow'>=</span> <span class='n'>fparse</span> <span class='n'>expr</span> <span class='mi'>0</span> <span class='kt'>[]</span> <span class='kt'>[]</span> <span class='kt'>[]</span> <span class='kt'>False</span>
</code></pre></div>
<p>The above code epitomizes the algorithm-as-a-definition approach that is Functional Programming. It is far more succinct than any prior communication of the algorithm, and simply a clearer representation than most people could communicate given complete freedom.</p>

<p>Hopefully you are beginning to understand what it means for a program to be functional and beginning to see the merits of a functional approach. If you wish to learn more about functional programming, scheme, lisp, or functional rudiments, checkout the following references.</p>

<ul>
<li>McCarthy&#8217;s <a href='http://www-formal.stanford.edu/jmc/recursive.pdf'>Recursive Functions of Symbolic Expressions and Their Computation by Machine</a> - The paper that introduced not only Lisp, but functional programming as well, to the world.</li>

<li><a href='http://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours'>Write Yourself a Scheme in 48 Hours</a> by Jonathan Tang - A tutorial on implementing a Scheme in Haskell.</li>

<li><em>Tarpits &amp; Abstraction</em> by Matt Neary - A book which has yet to be released on building languages, simulators, and layers of abstraction.</li>
</ul>
</div>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
  	"HTML-CSS": { linebreaks: { automatic: true } },
  	tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
  });
</script>
<script type="text/javascript"
  src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script>
	MathJax.Hub.Queue(["Typeset",MathJax.Hub]);
</script>

            <div class="footer">
              <div class="contact">
                <p>
                  Matt Neary<br />
                  Editor in Chief<br />
                  neary.matt@gmail.com
                </p>
              </div>
              <div class="contact">
                <p>
                  <a href="http://github.com/mattneary/">github.com/mattneary</a><br />
                  <a href="http://twitter.com/matt3141/">twitter.com/matt3141</a><br />
                </p>
              </div>
            </div>
          </div>
        </div> <!-- /container -->

    </body>
</html>
